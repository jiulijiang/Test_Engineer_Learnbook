# Python学习笔记

## 基础知识

### 变量
- 格式：变量名称 = 变量的值
- 作用：在程序运行的时候记录数据
- 特征：变量存储的值可以发生变化

### 数据类型
- `type()`可以用来查看数据的类型
- `type()`也可以用来查看变量内的数据类型，变量无类型，变量内的数据有类型
- **在Python中变量是没有类型的**

### 数据类型的转换
- `int(x)`将x转换成int型

### 标识符
- 标识符只可以使用英文中文数字下划线
- 大小写敏感
- 数字不可以用在开头，不推荐使用中文
- 不可使用关键字（如果大小写不一样不算占用关键字）
- **规范**：见名知意，下划线命名，英文字母全小写

### 字符串三种定义法
- 单引号定义 `'helloworld'`
- 双引号定义法 `"helloworld"`
- 三引号定义法 `"""helloworld"""` 三引号支持换行符，和多行定义一致

### 字符串的拼接
- 直接通过 `+` 拼接

### 字符串格式化
- `%s` 字符串
- `%d` 整数
- `%f` 浮点数
- 可使用 `m.n` 来控制数据的宽度和精度，m代表宽度，n代表精度
- 精度进行控制的时候数据会进行四舍五入，会产生失真

### 快速字符串格式化
- 快速格式化：`f"{占位}"`

### 表达式的格式化
- 表达式：一条具有明确执行结果的代码
- 可以直接把表达式放进快速格式化或者普通的格式化里面直接输出结果

### 数据输入
- `input`可用来从键盘获取内容
- 默认输入类型是字符串，可用数据类型转换实现，例如 `int(input())` 等

## Python判断语句

### 布尔类型的定义
- 布尔类型的变量只有 `True` 和 `False`
- 布尔类型可用比较运算进赋值

### if判断语句
```python
if 要判断的条件:
    条件成立时，要做的事情
```

### if else组合判断
- 满足if条件则执行if中的代码，不满足时执行else中的代码
- else语句不需要判断条件，当if语句不满足时自动执行else中的代码

### if_elif_else多条件组合判断
- 逐条判断条件序列中的条件，满足条件则进入并执行代码
- 全部不满足则进入else执行代码
- 判断是互斥且有序的，上面的满足了就不会执行下面的
- 可在判断中直接写input语句，可以节省代码量

### 判断语句的嵌套
- 通过多层嵌套可以满足复杂事件判断
- 当外层判断满足后进入内层判断，如果不满足则直接跳过
- 嵌套判断语句需要注意缩进，Python通过缩进来决定层次关系

## 循环语句

### 基础语法
```python
while 条件:
    条件满足时，运行的代码代码
```
- 只要条件满足就会一直执行
- 使用时确定终止条件

### `while`循环的嵌套使用
- 大循环套小循环，基于缩进来决定层次关系
- 注意条件设置，避免出现无限循环（除非真的需要）

### 补充知识

#### `print`输出自动换行
- 想要不换行可在后面加上 `end= ''`
- 即 `print("hello,world", end = '')`

#### 制表符 `\t`
- 制表符可以自动让多行内容对齐

### for循环
- while循环的循环条件是自定义的，自行控制循环条件
- for循环是一种轮询机制，是对一批内容进行逐个处理
- 无法定义循环条件，只能被动取出数据进行处理
- 注意循环语句的空格缩进
- `for()`循环和`while()`循环可以互相嵌套使用

### range语句
- 在for循环中，待处理数据集称之为 "序列类型"，其内容可以一个一个一次取出的一种类型，包括：字符串，列表，元组等
- 语法1：`range(num)`: 获取从0开始，到num结束的数字序列（不含num本身）
- 语法2：`range(num1, num2)`: 获得一个从num1开始，到num2结束的数字序列(不含num本身)
- 语法3：`range(num1, num2, step)`: 获得一个从num1开始，到num2结束的数字序列(不含num本身)，数字之间的步长以step为准(step默认为1)

### 补充知识点

#### 变量作用域
- 循环内的临时变量其作用域限定在循环内
- 限定是编程规范限定，并非强制限定
- 不遵守也可运行，但是不建议
- 如果有访问临时变量的需求，可以预先在循环外定义

### 循环中断
- `continue`：中断本次循环，直接进入下一次循环，`for()` `while()`循环均可使用
- `continue`可以用于循环中因为某些原因需要提前跳入下一次循环避免执行某些代码的场景
- `break`: 直接结束循环，`for()` `while()`循环均可使用
- `break`可以作用于某些需要提前结束循环的场景
- 两个函数都只作用于当前所在的循环语法中，不对嵌套循环中的其他语法起作用

## 函数

### 函数基本定义
- 函数：函数是组织好的，可重复使用的，用来实现特定功能的代码段
- 将功能封装在函数内，提高程序复用性，提高开发效率
- 先定义后使用
- 参数和返回值如果不需要可以直接省略

### 函数基本语法
```python
def 函数名(传入参数):
    函数体
    return 返回值
```

### 函数传入参数-传参定义
- 功能：在函数进行计算的时候，接收外部（调用时）提供数据
- 定义函数时，提供的x,y，称之为：形式参数，声明函数将要使用两个参数**参数之间使用逗号进行分割**

```python
def add(x, y):  # 定义函数
    results = x + y
    print(f"{x} + {y} = {results}")
add(5, 6)
```

- 函数调用时，提供的5和6，称之为：实际参数（实参），表示函数执行时真正使用的参数值，**传入时，按照顺序传入数据，使用逗号分隔**

### 函数返回值
- 作用：完成函数内代码后，返回给调用代码结果
- 函数体在遇到return之后就结束了，写在return之后的代码不会被执行
- 在不定义返回值的时候，会自动返回None，意思是返回无意义的内容，可主动写 `return None` 也可直接不写 `return语句`
- `None`可以用于声明无初始内容的变量

### 函数说明文档
- 可以通过多行注释来对函数进行说明，帮助更好的理解函数功能：

```python
def func(x, y):
    """
    函数说明
    :param x：形参x的说明
    :param y：形参y的说明
    :return：返回值的说明
    """
    函数体
    return返回值
```

### 函数的嵌套调用
- 定义：即在一个函数中再次调用了另一个函数

### 函数内变量作用域

#### 局部变量
- 局部变量就是定义在函数体内部的变量，即只在函数体内部生效，无法在函数外被调用
- 在函数运行的时候临时保存数据，函数调用完毕时即时销毁

#### 全局变量
- 全局变量是在函数体内，外都能生效的变量
- 全局变量可在所有函数中调用
  - 函数内部无法直接对变量进行修改
  - `global`关键字可以声明修改的变量为全局变量
  - 语法：`global 全局变量名称`

## 数据容器

### 数据容器的基本概念
- 一种可以容纳多份数据的python数据类型，容纳的每一份数据称之为1一个元素
- 每个元素可以是任意类型的数据，如字符串，数字，布尔等
- 数据容器根据特点不同，可以分为5类
  - 特点：
    - 是否支持重复元素
    - 是否可以修改
    - 是否有序，等
  - 类别:
    - 列表 `list`, 元组 `tuple`, 字符串 `str`, 集合 `set`, 字典`dict`

### list列表定义
- 基本语法：

```python
# 字面量
list1 = [元素1, 元素2, 元素3, 元素4]
# 定义变量
list2 = [元素1, 元素2, 元素3, 元素4]
# 定义空列表
list3 = []
list4 = list()
```

- 列表一次可以存储多个数据，**数据类型没有任何限制**
- 列表支持嵌套使用，可在一个列表中嵌套列表

### list列表的下表索引
- 列表中的每个数据都有自己的索引，根据索引可以取出对应的元素
- 列表下标索引可以支持反向使用，在索引前加上负号即可
- 如果是嵌套的列表，同样支持索引

```python
list1 = [1, 2, 3, [4, 5, 6], 7, 8, 9, 5]
print(list1[2])  # 正序输出
print(list1[-1])  # 倒序输出
print(list1[3][2])  # 嵌套列表的下标索引
```

### 列表常用操作（方法）
- 方法概念：在Python中，如果将函数定义为class(类)的成员，那么函数称之为：方法
- 查询元素的下标：
  - 功能：查找指定元素在列表中的下标索引
  - 语法：`列表.index(元素)`
- 修改也定位置的元素值：
  - 功能：对指定下标的值进行：重新赋值修改
  - 语法: `列表[下标] = 值`
- 插入元素：
  - 功能: 在指定下标位置插入指定元素
  - 语法：`列表.insert(下标，元素)`
- 追加元素1：
  - 功能：将指定元素插入列表尾部
  - 语法: `列表.append(元素)`
- 追加元素2：
  - 功能：将其他数据容器内数据取出，逐个追加到列表尾部
  - 语法: `列表.extend(其他数据容器)`
- 删除指定下标元素：
  - 语法1：`del 列表[下标]`
  - 语法2：`列表.pop(下标)`，下标输入则删除最后一个元素并返回该元素
- 删除指定元素在列表中的第一个匹配项
  - 语法：`列表.remove(元素)`
- 统计列表中全部元素数量

### 列表特点
- 可以容纳多个元素（上限2**63-1）
- 可以存储不同类型元素
- 数据是有序存储的（有下标序号）
- 允许重复数据存在
- 可以修改

### 列表的遍历
- while循环
  - 通过下标索引的方式取出
  - 定义一个变量表示下标，从0开始
  - 循环条件为：下标值<列表长度
- for循环
  - for循环特性可直接从数据容器中逐个取出元素

### 元组
- 元组特性：元组定义完成后不可被修改，如果不希望元素被修改就可以用元组
- 元组的定义：使用中括号去定义元组

```python
# 定义元组字面量
(元素，元素，元素)     # 定义元组变量
变量名称 = (元素，元素，元素)    # 定义空元组
变量名称 = ()    # 方式1
变量名称 = tuple()    # 方式2
```

- 定义单个元素时，需要加一个额外的逗号，例：`t1 = ("hello", )`
- 元组支持嵌套
- 元组支持下标索引取出内容
- 元组支持方法：
  - `index()`: 查找对应元素下标索引
  - `count()`: 统计某个元素出现次数
  - `len()` 统计元组元素个数
- 元组不可以修改，但是**元组中的`list()`类型数据可以修改**

### 字符串
- 字符串是字符的容器，一个字符串可以存放任意数量的字符，其中的每一个字符都是一个元素
- **字符串是不可修改的数据容器**
- 字符串的定义方法：见day_1.md
- 字符串常用方法：
  - 通过下标索引取值
  - index方法：查询元素对应下标值
  - replace方法：
    - 语法：`新字符串 = 字符串.replace(字符串1, 字符串2)`
    - 功能：将字符串内全部的 '字符串1' 替换为 '字符串2'
    - 注意：不是修改字符串本身，而是得到了一个新的字符串
  - 字符串的分割
    - 语法：`字符串.split(分隔符字符串)`
    - 功能：按照指定分隔符字符串，将字符串划分为多个字符串，并存入**列表对象中**
    - 注意：字符串本身不变，而是得到了一个列表对象
  - 字符串规整操作
    - 语法：`字符串.strip(字符串)`，字符串默认值为空格
    - 功能：去除前后指定字符串，不输入则默认去除前后空格
    - 注意：在字符串中按照单个字符串去除
  - 字符串某字符出现次数统计：`字符串.count(字符串)`
  - 统计字符串长度；`len(字符串)`
- 和列表元组一样，字符串也支持while循环和for循环遍历

### 序列的切片操作
- 列表元组字符串均可以视为序列
- **切片：**从一个序列中取出一个子序列
- 语法：`序列[start:stop:step]`
  - start：起始索引，默认为0
  - stop：结束索引，默认为序列长度
  - step：步长，默认为1

### 集合
- **集合**：无序且不重复的元素序列
- 基本语法：
  - `集合 = {元素1, 元素2, ...}`
  - `集合 = set()`
  - 不可以用{}来定义，{}已经被用来定义字典
- **添加新元素**: 
  - 语法：`集合.add(元素)`
- **删除元素：**
  - 语法：`集合.remove(元素)`
- **随机取出一个元素：**
  - 语法：`集合.pop()`
  - 删除并返回随机一个元素
- **清空元素：**
  - 语法：`集合.clear()`
- **取出两个集合的差集：**
  - 语法：`集合1.difference(集合2)`
  - 返回集合1与集合2的差集，集合1中的元素且在集合2中不存在
- **消除两个集合的差集：**
  - 语法：`集合1.difference_update(集合2)`
  - 删除集合1中在集合2中存在的元素
- **合并两个集合：**
  - 语法：`集合1.union(集合2)`
  - 返回集合1与集合2的并集，原集合不变
- **统计集合内元素数量：**
  - 语法：`len(集合)`
- 集合**不支持while**循环，但是集合**支持for循环**
- **特点：**
  - 可以容纳多个数据
  - 可以容纳不同类型的数据
  - 数据数无序存储的
  - 不允许重复数据
  - 可以修改
  - 支持for循环

### 字典
- **字典：**无序的键值对序列
- 基本语法：
  - `字典 = {键1:值1, 键2:值2, ...}`
  - `字典 = dict()`
  - `字典 = {}`
- 字典key值不允许重复，如果key值重复，则后面的key值会覆盖前面的key值
- 可以通过key值取出对应的value值：
  - 语法：`字典[key]`
- 字典的key和value值都可以是任意类型(key不可以是字典)
- **字典的嵌套：**
  - 语法：`字典 = {key1:{key2:value2, key3:value3}, key4:value4}`
- **新增\修改**字典元素：
  - 语法：`字典[key] = value`
  - 如果key不存在，则新增一个元素，如果key存在，则修改对应的value值
- **删除元素：**
  - 语法：`字典.pop(key)`
  - 删除并返回对应的key值所对应的value值
- **清空元素：**
  - 语法：`字典.clear()`
- **获取全部key值：**
  - 语法：`字典.keys()`
- **遍历字典：**
  - 语法：`for key in 字典:`
  - 逐个输出字典的key值
- **统计元素数量**: 
  - 语法：`len(字典)`

### 数据容器对比
- **是否支持下表索引：**
  - 支持：列表，元组，字符串 --序列类型
  - 不支持：集合，字典 --非序列类型
- **是否支持重复元素**
  - 支持：列表，元组，字符串 --序列类型
  - 不支持：集合，字典 --非序列类型
- **是否可以修改**
  - 支持：列表，集合，字典
  - 不支持：元组，字符串

| 特性     | 列表                       | 元组                       | 字符串           | 集合               | 字典                                 |
| -------- | -------------------------- | -------------------------- | ---------------- | ------------------ | ------------------------------------ |
| 元素数量 | 支持多个                   | 支持多个                   | 支持多个         | 支持多个           | 支持多个                             |
| 元素类型 | 任意                       | 任意                       | 仅字符           | 任意               | Key:Value   Key: 除字典外任意类型 Value：任意类型 |
| 下标索引 | 支持                       | 支持                       | 支持             | 不支持             | 不支持                               |
| 重复元素 | 支持                       | 支持                       | 支持             | 不支持             | 不支持                               |
| 可修改性 | 支持                       | 不支持                     | 不支持           | 支持               | 支持                                 |
| 数据有序 | 是                         | 是                         | 是               | 否                 | 否                                   |
| 使用场景 | 可修改、可重复的一批数据记录场景 | 不可修改、可重复的一批数据记录场景 | 一串字符的记录场景 | 不可重复的数据记录场景 | 以 Key 检索 Value 的数据记录场景     |

### 数据容器的通用操作
- **统计元素数量：**
  - 语法：`len(数据容器)`
- **寻找最大元素：**
  - 语法：`max(数据容器)`
- **寻找最小元素：**
  - 语法：`min(数据容器)`
- **类型转换：**
  - list(数据容器)
  - tuple(数据容器)
  - set(数据容器)
  - str(数据容器)
  - 注意，字典进行转换时，会丢失键值对关系，只保留键
- **排序功能：**
  - 语法：`sorted(数据容器, reverse=True/False)`
  - reverse参数为True时，表示降序排列，为False时，表示升序排列
  - 不填写reverse参数时，默认为升序排列

### ASCII码
- 程序中所有的字符都有其对应的ASCII码
- 字符串是按位比较，一位一位匹配，当前位数相同就顺延地比较下一位，直到某一位不同，就返回结果

## 函数进阶

### 函数多返回值
- 可以用`,`隔开多个返回值，例子：

```python
def test(a, b):
    return a + b, a * b    
```

- 返回值类型不受限，可以是任意类型
- 接收时也用`,`隔开

### 函数多种传参形式
- **位置参数**：通过位置来确定参数，位置参数必须按照顺序传入
- **关键字参数**：通过参数名来确定参数，关键字参数可以不按照顺序传入

```python
def test(a, b, c):
    print(a, b, c)
test(a=1, c=2, b=3)
```

- 位置参数可以和关键字参数混合使用，但是位置参数必须放在关键字参数前面来确定参数
- **缺省参数：**通过参数名来确定参数，如果参数没有传入，则使用缺省值

```python
def test(a, b, c=2):
    print(a, b, c)
test(1, 3)  # 没有输入c参数，则使用缺省值2，不会报错
```

  - 参数的顺序：位置参数，关键字参数，缺省参数，默认值必须放在最后
- **不定长参数：**
  - ***args：**可变参数，将参数保存在元组中

```python
def test(*args):
    print(args)
test(1, 2, 3)
# 结果：
# (1, 2, 3)
```

  - **kwargs：关键字参数，将参数保存在字典中

```python
def test(**kwargs):
    print(kwargs)
test(a=1, b=2, c=3)
# 结果：
# {'a': 1, 'b': 2, 'c': 3}
```

### 匿名函数
- **函数作为参数传递**
  - 这是一种函数作为逻辑的传递，而非数据的传递

```python
def test(fun):
    result = fun(1, 2)
    return result
def add(a, b):
    return a + b
test(add)
# 结果：
# 3
```

  - 意义解析：test()函数要求传入一个逻辑，test()会调用这个逻辑来完成自身的功能，传入函数是什么逻辑可以根据需求去更改对应函数，只要能够接收test()函数给的参数和返回逻辑结果就可以
- **lambda匿名函数：**
  - 函数定义中，**`def`关键字**可以用来定义带有名称的函数，**可以基于名称重复使用**
  - **`lambda`关键字**可以用来定义匿名函数(无名称)，无名称的**匿名函数只能使用一次**
  - 语法：`lambda [参数列表]: [表达式]`

```python
def test(fun):
    result = fun(1, 2)
    return result
test(lambda a, b: a + b)
```

  - 可以通过传入一个`lambda`匿名函数作为参数，来调用test函数
  - `lambda`只支持一行代码

## 文件操作

### 文件的编码
- 编码技术：翻译的规则，记录了如何将内容翻译成二进制，以及如何将二进制翻译成内容。
- 常见编码：UTF-8、GBK、GB2312等
- UTF-8编码是目前全球通用的编码，除非有特殊需求，一般都使用UTF-8编码

### 文件的读取
- 文件的类型：文本，视频，音频，图片，可执行文件等
- 文件主要操作：读取，写入，追加，修改，删除
- 打开文件:
  - `文件对象 = open("file_name", "mode", "encoding")`
    - file_name: 文件名(可以包含路径)
    - mode: 文件打开方式: r 只读，w: 只写，a: 追加
    - encoding: 文件编码
- 读取相关方法：
  - `文件对象.read(num)`: 读取文件内容
    - num: 读取指定字节数，下一次读取接着上次读取的位置开始，不传参则读取所有内容
  - `文件对象.readlines()`: 读取文件内容，返回列表，每一行作为一个元素
  - `文件对象.readline()`: 读取一行内容
  - `for`循环读取文件内容
    - for line in 文件对象: 循环读取每一行内容
- 关闭文件：`文件对象.close()`，不关闭文件会导致文件被持续占用

### with关键字
- 功能：自动管理文件的关闭，当with代码块运行完毕后，自动关闭文件，无论代码块是否正常运行完毕
- 语法：

```python
with open("file_name", "mode", "encoding") as 文件对象:
    文件操作代码
```

### 文件的写入
- 语法：`文件对象.write("内容")`
- 注意：写入时，如果文件不存在，会自动创建文件；如果文件存在，会覆盖文件内容
- 写入时，内容不会自动换行，需要手动添加换行符`\n`

### 文件的追加
- 语法：`文件对象.write("内容")`
- 注意：追加时，如果文件不存在，会自动创建文件；如果文件存在，会在文件末尾追加内容
- 追加时，内容不会自动换行，需要手动添加换行符`\n`

## 异常处理

### 异常的定义
- 异常：程序运行时发生的错误，会导致程序终止运行

### 异常的捕获
- 作用：在程序运行时，如果发生异常，可以通过捕获异常来避免程序终止运行
- 基础语法：

```python
try:
    可能出现异常的代码
except 异常类型:
    出现异常时执行的代码
```

### 捕获特定异常
- 语法：

```python
try:
    可能出现异常的代码
except 异常类型1:
    出现异常类型1时执行的代码
except 异常类型2:
    出现异常类型2时执行的代码
...
```

### 捕获全部异常
- 语法：

```python
try:
    可能出现异常的代码
except Exception:
    出现异常时执行的代码
```

- 捕获所有异常，Exception为所有异常的基类

### 异常的`else`模块
- 语法：没有出现异常时执行的代码模块，在`except`块之后衔接

### 异常的`finally`模块
- 语法：无论是否发生异常，都会执行的代码模块，在`else`模块之后衔接

### 异常的传递性
- 异常在调用中会传递，不必深入到最底层去捕获异常，可以在调用中捕获异常

### 抛出异常
- 语法：`raise 异常类型(异常信息)`
- 抛出异常后，程序会立即停止运行，并且会将异常信息打印出来
- 可以在`except`块中抛出异常，也可以在`else`块中抛出异常，也可以在`finally`块中抛出异常

## Python的模块

### 模块的定义
- **模块：** 一个模块就是一个py文件，模块名就是文件名，文件名必须为.py结尾，模块中存在类、函数、变量等，可以直接拿来用

### 导入模块
- 语法：
  - `import 模块名`
  - `import 模块名 as 别名`
  - `from 模块名 import 函数名/类名/变量名`
  - `from 模块名 import *` (不推荐使用，会导入所有内容，可能导致命名冲突)

### 自定义模块
- 自定义模块就是自己创建的py文件，文件名就是模块名
- 可以在其他py文件中导入自定义模块
- `__name__`变量：每个模块都有一个`__name__`变量，当模块被直接运行时，`__name__`变量的值为`"__main__"`；当模块被导入时，`__name__`变量的值为模块名
- `__all__`变量：在模块中定义`__all__`变量，可以控制`from 模块名 import *`导入的内容

```python
__all__ = ['func1', 'func2']
```

  如果导入该模块时使用`from 模块名 import *`，那么只会导入`func1`和`func2`这两个内容，而不会导入其他内容。

### 自定义Python包
- 从物理上看：包是一个包含多个模块的文件夹，包中必须包含一个`__init__.py`文件，`__init__.py`文件可以为空，也可以包含包的初始化代码
- 从逻辑上看：包的本质依然是模块，只不过是一个包含多个模块的模块
- `__init__.py`文件：包的初始化文件，表示当前文件夹是一个Python的包，当导入包时，`__init__.py`文件会被执行，可以在其中定义包的初始化代码，比如导入包中的模块、定义包的变量等
- 包的导入：使用`import 包名.模块名`或`from 包名 import 模块名`
- 包的使用：使用`.`来调用包中的模块内容
- 包的层级：可以通过多层包来组织模块，比如`import 包1.包2.模块名`

### 第三方包
- 第三方包是指由其他人开发的包，可以通过`pip`工具来安装和管理第三方包
- 安装第三方包：使用`pip install 包名`命令来安装第三方包
- 卸载第三方包：使用`pip uninstall 包名`命令来卸载第三方包
- 查看已安装的第三方包：使用`pip list`命令来查看已安装的第三方包
- 更新第三方包：使用`pip install --upgrade 包名`命令来更新第三方包
- `pip`网络优化：可以通过配置国内镜像来加速`pip`的下载速度，比如使用`阿里云`的镜像：

```python
pip install -i https://mirrors.aliyun.com/pypi/simple/ 包名 
```

## JSON数据格式

### JSON的概念
- JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，本质上是一个带有特定格式的字符串
- 主要功能：一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互

### JSON的基本格式

```json
{
    "name": "张三",
    "age": 18,
    "is_student": true,
    "courses": ["数学", "英语", "物理"],
    "address": {
        "city": "北京",
        "zip_code": "100000"
    }
}
```

- json数据格式相当于Python中的字典（dict），也可以是外面是列表，里面是字典的数据结构，比如：

```json
[
    {
        "name": "张三",
        "age": 18
    },
    {
        "name": "李四",
        "age": 19
    }
]
```

### Python中的JSON操作
- Python中提供了`json`模块来处理JSON数据
- **将Python对象转换为JSON字符串（序列化）：**
  - 语法：`json.dumps(Python对象)`
  - 参数：
    - Python对象：可以是字典、列表等
    - `ensure_ascii=False`：如果有中文，可以添加这个参数，确保中文正常显示
  - 返回值：JSON字符串

```python
import json

# 字典转JSON
my_dict = {"name": "张三", "age": 18}
json_str = json.dumps(my_dict, ensure_ascii=False)
print(json_str)  # 输出：{"name": "张三", "age": 18}
```

- **将JSON字符串转换为Python对象（反序列化）：**
  - 语法：`json.loads(JSON字符串)`
  - 返回值：Python对象（字典或列表）

```python
import json

# JSON转字典
json_str = '{"name": "张三", "age": 18}'
my_dict = json.loads(json_str)
print(my_dict)  # 输出：{'name': '张三', 'age': 18}
```

## 正则表达式

### 正则表达式的概念
- 正则表达式是一种用于匹配字符串中字符组合的模式，在Python中，通过`re`模块来使用正则表达式
- 应用场景：
  - 检查字符串是否符合某种格式（如邮箱、手机号等）
  - 从字符串中提取指定的信息
  - 替换字符串中的某些内容

### 正则表达式的使用步骤
1. 导入`re`模块
2. 定义正则表达式模式
3. 使用`re`模块中的函数进行匹配、查找、替换等操作

### 正则表达式的匹配函数
- `re.match`:从字符串的开头开始匹配，如果开头不匹配，则返回`None`

```python
import re

result = re.match(r"hello", "hello world")
print(result)  # 输出：<re.Match object; span=(0, 5), match='hello'>
```

- `re.search`:搜索整个字符串，找出第一个匹配的字符串就停止，返回匹配的字符串，如果没有匹配的字符串，则返回`None`

```python
s = "1python itheima python itheima python itheima"
result = re.search(r"python", s)
print(result)  # 输出：<re.Match object; span=(1, 7), match='python'>
```

- `re.findall`:匹配整个字符串，返回所有匹配的字符串，如果没有匹配的字符串，则返回空列表

```python
s = "1python itheima python itheima python itheima"
result = re.findall(r"python", s)
print(result)  # 输出：['python', 'python', 'python']
```

### 元字符匹配
- **单字符匹配**
  - `.`: 匹配任意字符，除了换行符，`\.`匹配本身
  - `[^]`: 匹配任意字符，除了括号列举的字符
  - `[]`: 匹配括号列举的字符
  - `\d`: 匹配数字，等价于`[0-9]`
  - `\D`: 匹配非数字，等价于`[^0-9]`
  - `\s`: 匹配空白字符，等价于`[ \t\n\r\f\v]`
  - `\S`: 匹配非空白字符，等价于`[^ \t\n\r\f\v]`
  - `\w`: 匹配单词字符，等价于`[a-zA-Z0-9_]`
  - `\W`: 匹配非单词字符，等价于`[^a-zA-Z0-9_]`

- **数量匹配**
  - `*`: 匹配0个或多个前面的字符
  - `+`: 匹配1个或多个前面的字符
  - `?`: 匹配0个或1个前面的字符
  - `{n}`: 匹配n个前面的字符
  - `{n,}`: 匹配n个或多个前面的字符
  - `{n,m}`: 匹配n到m个前面的字符

- **边界匹配**
  - `^`: 匹配字符串的开头
  - `$`: 匹配字符串的结尾
  - `\b`: 匹配单词边界
  - `\B`: 匹配非单词边界

- **分组匹配**
  - `()`: 匹配括号内的内容
  - `|`: 匹配左右任意一个表达式

### 递归
- 概念：即函数(方法)直接调用自身的特殊编程写法

```python
def fun():
    if ...:
        fun()
    return ...
```

- 使用场景：
  - 解决一些复杂问题时，可以使用递归来简化代码
  - 例如：寻找文件，树形结构的遍历、汉诺塔问题、斐波那契数列等
- 注意事项：
  - 递归调用的终止条件必须明确，否则容易变成无限递归
  - 确保返回值的传递，确保从最内层，一层层返回到最外层

---
基础Python到此结束  
**完结撒花**