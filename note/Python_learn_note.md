# python学习笔记

## 基础知识

### 变量

- 格式： 变量名称 = 变量的值
- 作用： 在程序运行的时候记录数据
- 特征： 变量存储的值可以发生变化  

### 数据类型  

- `type()`可以用来查看数据的类型
- `type()`也可以用来查看变量内的数据类型，变量无类型，变量内的数据有类型
- **在Python中变量是没有类型的**  

### 数据类型的转换

- `int(x)`将x转换成int型  

### 标识符  

- 标识符只可以使用英文中文数字下划线
- 大小写敏感
- 数字不可以用在开头，不推荐使用中文
- 不可使用关键字（如果大小写不一样不算占用关键字）
- **规范**：见名知意，下划线命名，英文字母全小写  

### 字符串三种定义法

- 单引号定义 `'helloworld'`
- 双引号定义法 `"helloworld"`
- 三引号定义法 `"""helloworld"""`三引号支持换行符，和多行定义一致

### 字符串的拼接

- 直接通过 `+` 拼接

### 字符串格式化

- `%s`字符串
- `%d`整数
- `%f`浮点数
- 可使用 `m.n`来控制数据的宽度和精度，m代表宽度，n代表精度
- 精度进行控制的时候数据会进行四舍五入，会产生失真

### 快速字符串格式化

- 快速格式化： `f "{占位}"`

### 表达式的格式化

- 表达式：一条具有明确执行结果的代码
- 可以直接把表达式放进快速格式化或者普通的格式化里面直接输出结果  

### 数据输入

- `input`可用来从键盘获取内容
- 默认输入类型是字符串，可用数据类型转换实现，例如 `int(input())`等

## pyhon判断语句

### 布尔类型的定义

- 布尔类型的变量只有 `true`和 `false`
- 布尔类型可用比较运算进赋值

### if判断语句

- `if 要判断的条件: 条件成立时，要做的事情`

### if else组合判断

- 满足if条件则执行if中的代码，不满足时执行else中的代码
- else语句不需要判断条件，当if语句不满足时自动执行else中的代码

### if_elif_else多条件组合判断

- 逐条判断条件序列中的条件，满足条件则进入并执行代码
- 全部不满足则进入else执行代码
- 判断是互斥切有序的，上面的满足了就不会执行下面的
- 可在判断中直接写input语句，可以节省代码量

### 判断语句的嵌套

- 通过多层嵌套可以满足复杂事件判断
- 当外层判断满足后进入内层判断，如果不满足则直接跳过
- 嵌套判断语句需要注意缩进，Python通过缩进来决定层次关系

## 循环语句

### 基础语法

`while 条件:`  
    `条件满足时，运行的代码代码`

- 只要条件满足就会一直执行
- 使用时确定终止条件

### `while`循环的嵌套使用

- 大循环套小循环，基于缩进来决定层次关系
- 注意条件设置，避免出现无限循环（除非真的需要）

### 补充知识

#### `print`输出自动换行

- 想要不换行可在后面加上 `end= ''`
- 即 `print( "hello,world", end = '' )`

#### 制表符 `\t`

- 制表符可以自动让多行内容对齐

### for循环

- while循环的循环条件是自定义的，自行控制循环条件
- for循环是一种轮询机制，是对一批内容进行逐个处理
- 无法定义循环条件，只能被动取出数据进行处理
- 注意循环语句的空格缩进
- `for()`循环和 `while()`循环可以互相嵌套使用

### range语句

- 在for循环中，待处理数据集称之为 "序列类型"，其内容可以一个一个一次取出的一种类型，包括：字符串，列表，元组等
- 语法1： `range(num)`:获取从0开始，到num结束的数字序列（不含num本身）
- 语法2： `range(num1,num2)`:获得一个从num1开始，到num2结束的数字序列(不含num本身)
- 语法3： `range(num1,num2,step)`:获得一个从获得一个从num1开始，到num2结束的数字序列(不含num本身)，数字之间的步长以step为准(step默认为1)

### 补充知识点

#### 变量作用域

- 循环内的临时变量其作用域限定在循环内
- 限定是编程规范限定，并非强制限定
- 不遵守也可运行，但是不建议
- 如果有访问临时变量的需求，可以预先在循环外定义

### 循环中断

- `continue`：中断本次循环，直接进入下一次循环， `for()` `while()`循环均可使用
- `continue`可以用于循环中因为某些原因需要提前跳入下一次循环避免执行某些代码的场景
- `break`:直接结束循环，`for()` `while()`循环均可使用
- `break`可以作用于某些需要提前结束循环的场景
- 两个函数都只作用于当前所在的循环语法中，不对嵌套循环中的其他语法起作用

## 函数

### 函数基本定义

- 函数：函数是组织好的，可重复使用的，用来实现特定功能的代码段
- 将功能封装在函数内，提高程序复用性，提高开发效率
- 先定义后使用
- 参数和返回值如果不需要可以直接省略

### 函数基本语法

    def 函数名(传入参数):
        函数体
        return 返回值

### 函数传入参数-传参定义

- 功能：在函数进行计算的时候，接收外部（调用时）提供数据
- 定义函数时，提供的x,y，称之为：形式参数，声明函数将要使用两个参数**参数之间使用逗号进行分割**  

    def add(x,y): #定义函数
          results = x + y
          print(f"{x} + {y} = {results}")
    add(5,6)
- 函数调用时，提供的5和6，称之为：实际参数（实参），表示函数执行时真正使用的参数值，**传入时，按照顺序传入数据，使用逗号分隔**

### 函数返回值

- 作用：完成函数内代码后，返回给调用代码结果
- 函数体在遇到return之后就结束了，写在return之后的代码不会被执行
- 在不定义返回值的时候，会自动返回None，意思是返回无意义的内容，可主动写 `return None`也可直接不写 `return语句`
- `None`可以用于声明无初始内容的变量

### 函数说明文档

- 可以通过多行注释来对函数进行说明,帮助更好的理解函数功能：

    def func(x, y):
        """
        函数说明
        :paramx：形参x的说明
        :paramy：形参y的说明
        :return：返回值的说明
        """
        函数体
        return返回值

### 函数的嵌套调用

- 定义：即在一个函数中再次调用了另一个函数

### 函数内变量作用域

#### 局部变量

- 局部变量就是定义在函数体内部的变量，即只在函数体内部生效，无法在函数外被调用
- 在函数运行的时候临时保存数据，函数调用完毕时即时销毁

#### 全局变量

- 全局变量是在函数体内，外都能生效的变量
- 全局变量可在所有函数中调用
  - 函数内部无法直接对变量进行修改
  - `global`关键字可以声明修改的变量为全局变量
  - 语法： `global 全局变量名称`

## 数据容器

### 数据容器的基本概念

- 一种可以容纳多份数据的python数据类型，容纳的每一份数据称之为1一个元素
- 每个元素可以是任意类型的数据，如字符串，数字，布尔等
- 数据容器根据特点不同，可以分为5类
  - 特点：
    - 是否支持重复元素
    - 是否可以修改
    - 是否有序，等
  - 类别:
    - 列表 `list`,元组 `tuple`, 字符串 `str`,集合 `set`,字典`dict`

### list列表定义

- 基本语法：

        # 字面量
        list1=[元素1,元素2,元素3,元素4]
        # 定义变量
        list2 = [元素1,元素2,元素3,元素4]
        # 定义空列表
        list3 = []
        list4 = list()
- 列表一次可以存储多个数据，**数据类型没有任何限制**
- 列表支持嵌套使用，可在一个列表中嵌套列表

### list列表的下表索引

- 列表中的每个数据都有自己的索引，根据索引可以取出对应的元素
- 列表下标索引可以支持反向使用，在索引前加上负号即可
- 如果是嵌套的列表，同样支持索引

```python
list1 = [1, 2, 3, [4, 5, 6], 7, 8, 9, 5]
print(list1[2])  # 正序输出
print(list1[-1])  # 倒序输出
print(list1[3][2])  # 嵌套列表的下标索引
```

### 列表常用操作（方法）

- 方法概念：在Python中，如果将函数定义为class(类)的成员，那么函数称之为：方法
- 查询元素的下标：
  - 功能：查找指定元素在列表中的下标索引
  - 语法： `列表.index(元素)`
- 修改也定位置的元素值：
  - 功能：对指定下标的值进行：重新赋值修改
  - 语法:  `列表[下标] = 值`
- 插入元素：
  - 功能:在指定下标位置插入指定元素
  - 语法： `列表.insert(下标，元素)`
- 追加元素1：
  - 功能：将指定元素插入列表尾部
  - 语法: `列表.append(元素)`
- 追加元素2：
  - 功能：将其他数据容器内数据取出，逐个追加到列表尾部
  - 语法: `列表.axtend(其他数据容器)`
- 删除指定下标元素：
  - 语法1： `del 列表[下标]`
  - 语法2： `列表.pop(下标)`，下标输入则删除最后一个元素并返回该元素
- 删除指定元素在列表中的第一个匹配项
  - 语法： `列表.remove(元素)`
- 统计列表中全部元素数量

### 列表特点

- 可以容纳多个元素（上限2**63-1）
- 可以存储不同类型元素
- 数据是有序存储的（有下标序号）
- 允许重复数据存在
- 可以修改

### 列表的遍历

- while循环
  - 通过下标索引的方式取出
  - 定义一个变量表示下标，从0开始
  - 循环条件为：下标值<列表长度
- for循环
  - for循环特性可直接从数据容器中逐个取出元素

### 元组

- 元组特性：元组定义完成后不可被修改，如果不希望元素被修改就可以用元组
- 元组的定义：使用中括号去定义元组

    #定义元组字面量
    (元素，元素，元素)     #定义元组变量
    变量名称=(元素，元素，元素)    #定义空元组
    变量名称= ()    # 方式1
    变量名称=tuple()    # 方式2
- 定义单个元素时，需要加一个额外的逗号，例： `t1 = ( "hello", )`
- 元组支持嵌套
- 元组支持下标索引取出内容
- 元组支持方法：
  - `index()`:查找对应元素下标索引
  - `count()`:统计某个元素出现次数
  - `len()`统计元组元素个数
-元组不可以修改，但是**元组中的 `list()`类型数据可以修改**

### 字符串

- 字符串是字符的容器，一个字符串可以存放任意数量的字符，其中的每一个字符都是一个元素
- **字符串是不可修改的数据容器**
- 字符串的定义方法：见day_1.md
- 字符串常用方法：
  - 通过下标索引取值
  - index方法：查询元素对应下标值
  - replace方法：
    - 语法：`新字符串 = 字符串.replace(字符串1,字符串2)`
    - 功能：将字符串内全部的 '字符串1'替换为 '字符串2'
    - 注意：不是修改字符串本身，而是得到了一个新的字符串
  - 字符串的分割
    - 语法： `字符串。split(分隔符字符串)`
    - 功能：按照指定分隔符字符串，将字符串划分为多个字符串，并存入**列表对象中**
    - 注意：字符串本身不变，而是得到了一个列表对象
  - 字符串规整操作
    - 语法： `字符串.strip(字符串)`，字符串默认值为空格
    - 功能：去除前后指定字符串，不输入则默认去除前后空格
    - 注意：在字符串中按照单个字符串去除
  - 字符串某字符出现次数统计： `字符串.count(字符串)`
  - 统计字符串长度； `len(字符串)`
- 和列表元组一样，字符串也支持while循环和for循环遍历

### 序列的切片操作

- 列表元组字符串均可以视为序列
- **切片：**从一个序列中取出一个子序列
- 语法：`序列[start:stop:step]`
  - start：起始索引，默认为0
  - stop：结束索引，默认为序列长度
  - step：步长，默认为1

### 集合

- **集合**：无序且不重复的元素序列
- 基本语法：
  - `集合 = {元素1, 元素2, ...}`
  - `集合 = set()`
  - 不可以用{}来定义，{}已经被用来定义字典
- **添加新元素**:
  - 语法：`集合.add(元素)`
- **删除元素：**
  - 语法：`集合.remove(元素)`
- **随机取出一个元素：**
  - 语法：`集合.pop()`
  - 删除并返回随机一个元素
- **清空元素：**
  - 语法：`集合.clear()`
- **取出两个集合的差集：**
  - 语法：`集合1.difference(集合2)`
  - 返回集合1与集合2的差集，集合1中的元素且在集合2中不存在
- **消除两个集合的差集：**
  - 语法：`集合1.difference_update(集合2)`
  - 删除集合1中在集合2中存在的元素
- **合并两个集合：**
  - 语法：`集合1.union(集合2)`
  - 返回集合1与集合2的并集，原集合不变
- **统计集合内元素数量：**
  - 语法：`len(集合)`
- 集合**不支持while**循环，但是集合**支持for循环**
- **特点：**
  - 可以容纳多个数据
  - 可以容纳不同类型的数据
  - 数据数无序存储的
  - 不允许重复数据
  - 可以修改
  - 支持for循环

### 字典

- **字典：**无序的键值对序列
- 基本语法：
  - `字典 = {键1:值1, 键2:值2, ...}`
  - `字典 = dict()`
  - `字典 = {}`
- 字典key值不允许重复，如果key值重复，则后面的key值会覆盖前面的key值
- 可以通过key值取出对应的value值：
  - 语法：`字典[key]`
- 字典的key和value值都可以是任意类型(key不可以是字典)
- **字典的嵌套：**
  - 语法：`字典 = {key1:{key2:value2, key3:value3}, key4:value4}`
- **新增\修改**字典元素：
  - 语法：`字典[key] = value`
  - 如果key不存在，则新增一个元素，如果key存在，则修改对应的value值
- **删除元素：**
  - 语法：`字典.pop(key)`
  - 删除并返回对应的key值所对应的value值
- **清空元素：**
  - 语法：`字典.clear()`
- **获取全部key值：**
  - 语法：`字典.keys()`
- **遍历字典：**
  - 语法：`for key in 字典:`
  - 逐个输出字典的key值
- **统计元素数量**:
  - 语法：`len(字典)`

### 数据容器对比

- **是否支持下表索引：**
  - 支持：列表，元组，字符串 --序列类型
  - 不支持：集合，字典 --非序列类型
- **是否支持重复元素**
  - 支持：列表，元组，字符串 --序列类型
  - 不支持：集合，字典 --非序列类型
- **是否可以修改**
  - 支持：列表，集合，字典
  - 不支持：元组，字符串

| 特性   | 列表               | 元组                | 字符串       | 集合          | 字典                       |
| ---- | ---------------- | ----------------- | --------- | ----------- | ------------------------ |
| 元素数量 | 支持多个             | 支持多个              | 支持多个      | 支持多个        | 支持多个                     |
| 元素类型 | 任意               | 任意                | 仅字符       | 任意          | Key:Value   Key: 除字典外任意类型 Value：任意类型             |
| 下标索引 | 支持               | 支持                | 支持        | 不支持         | 不支持                      |
| 重复元素 | 支持               | 支持                | 支持        | 不支持         | 不支持                      |
| 可修改性 | 支持               | 不支持               | 不支持       | 支持          | 支持                       |
| 数据有序 | 是                | 是                 | 是         | 否           | 否                        |
| 使用场景 | 可修改、可重复的一批数据记录场景 | 不可修改、可重复的一批数据记录场景 | 一串字符的记录场景 | 不可重复的数据记录场景 | 以 Key 检索 Value 的数据记录场景   |

### 数据容器的通用操作

- **统计元素数量：**
  - 语法：`len(数据容器)`
- **寻找最大元素：**
  - 语法：`max(数据容器)`
- **寻找最小元素：**
  - 语法：`min(数据容器)`
- **类型转换：**
  - list(数据容器)
  - tuple(数据容器)
  - set(数据容器)
  - str(数据容器)
  - 注意，字典进行转换时，会丢失键值对关系，只保留键
- **排序功能：**
  - 语法：`sorted(数据容器,reverse=True/False)`
  - reverse参数为True时，表示降序排列，为False时，表示升序排列
  - 不填写reverse参数时，默认为升序排列

### ASCII码

- 程序中所有的字符都有其对应的ASCII码
- 字符串是按位比较，一位一位匹配，当前位数相同就顺延地比较下一位，直到某一位不同，就返回结果

## 函数进阶

### 函数多返回值

- 可以用`,`隔开多个返回值,例子：

        def test(a, b):
            return a + b, a * b    
- 返回值类型不受限，可以是任意类型
- 接收时也用`,`隔开

### 函数多种传参形式

- **位置参数**：通过位置来确定参数，位置参数必须按照顺序传入
- **关键字参数**：通过参数名来确定参数，关键字参数可以不按照顺序传入

        def test(a, b, c):
            print(a, b, c)
        test(a=1,c=2,b=3)
- 位置参数可以和关键字参数混合使用，但是位置参数必须放在关键字参数前面来确定参数
- **缺省参数：**通过参数名来确定参数，如果参数没有传入，则使用缺省值

        def test(a, b, c=2):
            print(a, b, c)
        test(1,3) #没有输入c参数，则使用缺省值2，不会报错
  - 参数的顺序：位置参数，关键字参数，缺省参数，默认值必须放在最后
- **不定长参数：**
  - ***args：**可变参数，将参数保存在元组中

            def test(*args):
                print(args)
            test(1,2,3)
            结果：
            (1, 2, 3)

  - **kwargs：关键字参数，将参数保存在字典中

            def test(**kwargs):
                print(kwargs)
            test(a=1,b=2,c=3)
            结果：
            {'a': 1, 'b': 2, 'c': 3}

### 匿名函数

- **函数作为参数传递**
  - 这是一种函数作为逻辑的传递，而非数据的传递

            def test(fun):
                result = fun(1,2)
                return result
            def add(a,b):
                return a+b
            test(add)
            结果：
            3
  - 意义解析：test()函数要求传入一个逻辑，test()会调用这个逻辑来完成自身的功能，传入函数是什么逻辑可以根据需求去更改对应函数，只要能够接收test()函数给的参数和返回逻辑结果就可以
- **lambda匿名函数：**
  - 函数定义中，**`def`关键字**可以用来定义带有名称的函数，**可以基于名称重复使用**
  - **`lambda`关键字**可以用来定义匿名函数(无名称),无名称的**匿名函数只能使用一次**
  - 语法：`lambda [参数列表]:[表达式]`

            def test(fun):
                result = fun(1,2)
                return result
            test(lambda a,b:a+b)
  - 可以通过传入一个`lambda`匿名函数作为参数，来调用test函数
  - `lambda`只支持一行代码

## 文件操作

### 文件的编码

- 编码技术：翻译的规则，记录了如何将内容翻译成二进制，以及如何将二进制翻译成内容。
- 常见编码：UTF-8、GBK、GB2312等
- UTF-8编码是目前全球通用的编码，除非有特殊需求，一般都使用UTF-8编码

### 文件的读取

- 文件的类型：文本，视频，音频，图片，可执行文件等
- 文件主要操作：读取，写入，追加，修改，删除
- 打开文件:
  - `文件对象 = open("file_name", "mode", "encoding")`
    - file_name: 文件名(可以包含路径)
    - mode: 文件打开方式:r 只读，w: 只写，a: 追加
    - encoding: 文件编码
- 读取相关方法：
  - `文件对象.read(num)`: 读取文件内容
    - num: 读取指定字节数,下一次读取接着上次读取的位置开始，不传参则读取所有内容
  - `文件对象.readlines()`: 读取文件内容，返回列表，每一行作为一个元素
  - `文件对象.readline()`: 读取一行内容
  - `for`循环读取文件内容
    - for line in 文件对象:循环读取每一行内容
- 关闭文件：`文件对象.close()`，不关闭文件会导致文件被持续占用
- `whith open("文件名","模式", "encoding") as 文件对象:`: 创建文件对象，并自动关闭文件对象

### 文件的写入

- `open("文件名", "r", "encoding")`: 创建文件对象,使用`w`模式写入文件
- `文件对象.write(内容)`: 向文件中写入内容，如果文件不存在，则创建文件，`w`模式下会覆盖文件原本内容
- `文件对象.flush()`: 刷新文件对象，将文件对象中的内容真正写入文件
- `.close()`方法是带有`flush()`方法的
- 写入内容会覆盖文件原本内容

### 追加写入

- `open("文件名", "a", "encoding")`: 创建文件对象,使用`a`模式追加写入文件
- `文件对象.write(内容)`: 向文件中写入内容，如果文件不存在，则创建文件，`a`模式下追加写入文件
- 追加写入内容不会覆盖文件原本内容，会在文件末尾追加内容

## 异常处理
### 异常模块  

**异常**:当检测到一个错误时，Python解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的“异常”，也就是我们常说的BUG  
**捕获异常**:提前预设某处存在异常，做好准备，当异常出现时，就进行相应的处理

### **捕获常规异常：**
  - 基本语法：
  ```python
    try:
        可能发生异常的代码
    except:
        处理异常的代码
  ```
- **捕获指定异常：**
  - 基本语法：
  ```python
    try:
        可能发生异常的代码
    except 异常类型 as 异常变量名:
        处理异常的代码
    ```
  - 捕获指定异常，不会捕获其他异常
  - 异常变量中存储着异常的信息
### **捕获多个异常：**
  - 基本语法：
  ```python
    try:
        可能发生异常的代码
    except (异常类型1, 异常类型2) as 异常变量名:
        处理异常的代码
  ```
  - 捕获多个异常，多个异常用逗号隔开
### **捕获所有异常：**
  - 常规异常捕获即可捕获全部异常
  - 语法2：
  ```python
    try:
        可能发生异常的代码
    except Exception as 异常变量名:
        处理异常的代码
  ```
  - 捕获所有异常，Exception为所有异常的基类

- **异常的`else`模块：**
  - 语法：没有出现异常时执行的代码模块，在`expext`块之后衔接

- **异常的`finally`模块：**
  - 语法：无论是否发生异常，都会执行的代码模块，在`else`模块之后衔接
- **异常的传递性：** 异常在调用中会传递，不必深入到最底层去捕获异常，可以在调用中捕获异常

### **抛出异常：**

- 语法：`raise 异常类型(异常信息)`
- 抛出异常后，程序会立即停止运行，并且会将异常信息打印出来
- 可以在`except`块中抛出异常，也可以在`else`块中抛出异常，也可以在`finally`块中抛出异常

## Python的模块

- **模块：** 一个模块就是一个py文件，模块名就是文件名，文件名必须为.py结尾，模块中存在类、函数、变量等，可以直接拿来用
- **导入模块：**
  - 语法：`[from 模块名] import [模块 | 类 | 函数 | 变量 | *] [as 别名]`
  - `*`：表示导入模块中所有内容
- **模块的使用：**
  - 语法：`模块名.模块内容`
  - 可以通过`.`来调用模块中所有的内容
- **导入模块特点功能：**
  - 通过`from 模块名 import 模块内容`导入模块内容，可以导入多个内容，多个内容之间用`,`隔开
  - 可以通过`as`来给模块内容起别名
- **自定义模块：**
  - `__name__变量`：当模块被直接运行时，`__name__`变量的值为`__main__`，当模块被导入时，`__name__`变量的值为模块名，可以通过判断`__name__`变量的值来决定模块的运行方式，比如在模块中添加以下代码：
    ```python
        if __name__ == '__main__':
            # 这里是模块的测试代码
            pass    
    ```
    这样在模块进行内部测试的时候，就可以使用`if __name__ == '__main__'`来判断，只有当模块被直接运行时才会执行`if __name__ == '__main__'`中的代码。


  - `__all__`变量：用于定义模块中可以被导入的内容，`__all__`是一个列表，包含了模块中所有可以被导入的内容的名称，比如：
    ```python
          __all__ = ['func1', 'func2']
    ```
      如果导入该模块时使用`from 模块名 import *`，那么只会导入`func1`和`func2`这两个内容，而不会导入其他内容。

- **自定义Python包：**
  - 从物理上看：包是一个包含多个模块的文件夹，包中必须包含一个`__init__.py`文件，`__init__.py`文件可以为空，也可以包含包的初始化代码
  - 从逻辑上看：包的本质依然是模块，只不过是一个包含多个模块的模块
  - `__init__.py`文件：包的初始化文件，表示当前文件夹是一个Python的包，当导入包时，`__init__.py`文件会被执行，可以在其中定义包的初始化代码，比如导入包中的模块、定义包的变量等
  - 包的导入：使用`import 包名.模块名`或`from 包名 import 模块名`
  - 包的使用：使用`.`来调用包中的模块内容
  - 包的层级：可以通过多层包来组织模块，比如`import 包1.包2.模块名`
- **第三方包：**
  - 第三方包是指由其他人开发的包，可以通过`pip`工具来安装和管理第三方包
  - 安装第三方包：使用`pip install 包名`命令来安装第三方包
  - 卸载第三方包：使用`pip uninstall 包名`命令来卸载第三方包
  - 查看已安装的第三方包：使用`pip list`命令来查看已安装的第三方包
  - 更新第三方包：使用`pip install --upgrade 包名`命令来更新第三方包
  - `pip`网络优化：可以通过配置国内镜像来加速`pip`的下载速度，比如使用`阿里云`的镜像：

    ```python
        pip install -i https://mirrors.aliyun.com/pypi/simple/ 包名 
    ```

## JSON数据格式

- JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，本质上是一个带有特定格式的字符串
- 主要功能：一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互
- JSON的基本格式：

    ```json
    {
        "name": "张三",
        "age": 18,
        "is_student": true,
        "courses": ["数学", "英语", "物理"],
        "address": {
            "city": "北京",
            "zip_code": "100000"
        }
    }
    ```  

  - json数据格式相当于Python中的字典（dict），也可以是外面是列表，里面是字典的数据结构，比如：

    ```json
    [
        {
            "name": "张三",
            "age": 18
        },
        {
            "name": "李四",
            "age": 20
        }
    ]
    ```

- Python数据和json数据转换：
  - Python对象转json字符串：使用`json.dumps(data)`方法,如果有中文，需要设置`ensure_ascii=False`
  - json字符串转Python对象：使用`json.loads(data)`方法
  - `data`是一个Python对象，可以是字典或者嵌套字典的列表等

## `pyecharts`模块

- `pyecharts`是一个用于生成图表的Python库，支持多种图表类型，如折线图、柱状图、饼图等
- `pyecharts`的安装：使用`pip install pyecharts`命令安装
- 构建基础折线图：

    ```python
    #导包，导入Line类
    from pyecharts.charts import Line  
    #创建Line对象
    line = Line()
    #添加x轴数据
    line.add_xaxis(["1月", "2月", "3月", "4月", "5月"])
    #添加y轴数据
    line.add_yaxis("销售额", [120, 200, 150, 80, 70])
    #生成图表
    line.render("line_chart.html")
    ```

  - `add_yaxis`方法添加y轴数据，参数包括系列名称和数据列表。
  - `add_xaxis`方法添加x轴数据，参数为一个列表。
  - `render`方法生成图表并保存为HTML文件，可以在浏览器中查看。
- `set_global_opts`方法设置全局配置项，如标题、图表大小、坐标轴标签、工具栏等。

    ```python
    line.set_global_opts(
        title="销售数据",  # 设置图表标题
        xaxis_title="月份",  # 设置x轴标题
        yaxis_title="销售额",  # 设置y轴标题
        toolbox_opts={  # 添加工具栏
            "show": True,
            "feature": {
                "saveAsImage": {}
            }
        }
    )
    ```

  - 标题配置:`title = "标题"`
  - x轴配置:`xaxis_title = "x轴标题"`
  - y轴配置:`yaxis_title = "y轴标题"`
  - 工具栏配置:`toolbox_opts = {"show": True, "feature": {"saveAsImage": {}}}`，可以添加保存为图片等功能
  - 更多功能可以参考`pyecharts`的[官方文档](https://pyecharts.org/#/zh-cn/global_options)，了解如何自定义图表样式、添加图例、设置颜色等。

## 面向对象

- **初识对象：** 对象是对现实世界中事物的抽象，具有属性和方法。
  - **类的定义：** 类是对象的蓝图，通过类可以创建多个对象。
  - **实例化：** 通过类创建对象的过程称为实例化。
  - **属性与方法：** 对象的属性是描述其特征的数据，方法是对象可以执行的操作。
  - 就像是现实世界的一张表格，设计表格是"创建类”，打印表格是"实例化类"，也叫“创建对象”，填写表格是“对象属性赋值”

### **类的定义和使用：**

  - 类的定义语法：

    ```python
    class ClassName:
        name = ""  # 属性示例

        def run(self):
            print("对象正在运行")
    ```

    - `class` 关键字用于定义类，`ClassName` 是类的名称，通常以大写字母开头。
    - 类的属性是类的变量，用于存储类的数据。（成员变量）
    - 类的行为是类的方法，用于定义类可以执行的操作。(成员方法)
  - 类的方法：
    - 类的方法是定义在类内部的函数，用于定义类的行为。
    - 方法的第一个参数通常是 `self`，表示类的实例本身。
    - 方法可以访问类的属性和其他方法。
    - 定义语法：

        ```python  
        def method_name(self, 其他参数):
            方法体
        ```

### **类和对象的关系：**

  - 类是对象的模板或蓝图，对象是类的实例。
  - 一个类可以创建多个对象，每个对象都有自己的属性和方法。
  - 类定义了对象的行为和状态，而对象是类的具体实现。

    ```python
    class Clock:
        def __init__(self, id=None, price=None):
            # __init__ 是构造方法，用于初始化对象属性
            self.id = id  # 对象属性: 对象id
            self.price = price  # 对象属性: 对象价格

        def ring(self):
            print("叮铃铃...")

    clock1 = Clock(id=1, price=100)  # 实例化对象并初始化属性
    clock1.ring()
    ```

  - ``__init__`` 方法是类的构造方法，用于初始化对象的属性,
      当创建对象时会自动调用。
  - ``__init__`` 方法的第一个参数必须是 `self`，用于接收实例本身，其他参数用于初始化属性，方法没有返回值（返回None）。

### **常用内置方法：**

  - `__str__` 方法：返回对象的字符串表示，通常用于打印对象。

    ```python
    class student:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        def __str__(self):
            return "姓名：%s，年龄：%s" % (self.name, self.age)
    stu1 = student("张三", 18)
    print(stu1)  # 结果为："姓名：张三，年龄：18"，如果没有设置__str__方法，则打印对象时，默认打印对象的内存地址
    ```

  - `__lt__` 方法：用于比较两个对象的大小，通常用于排序。(只用于小于,大于)

    ```python
    class student:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        def __lt__(self, other):
            return self.age < other.age
    stu1 = student("张三", 18)
    stu2 = student("李四", 20)
    print(stu1 < stu2)  # 结果为：True,如果不设置__lt__方法，会直接报错
    ```

  - `__le__` 方法：用于比较两个对象大小，通常用于排序。(只用于小于等于,大于等于)

    ```python
    class student:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        def __le__(self, other):
            return self.age <= other.age
    stu1 = student("张三", 18)
    stu2 = student("李四", 20)
    print(stu1 <= stu2)  # 结果为：True,如果不设置__le__方法，会直接报错
    ```

  - `__eq__`方法：用于比较两个对象是否相等，通常用于查找。(只用于等于)

    ```python
    class student:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        def __eq__(self, other):
            return self.age == other.age
    stu1 = student("张三", 18)
    stu2 = student("李四", 20)
    print(stu1 == stu2)  # 结果为：False,如果不设置__eq__方法，会直接报错
    ```

### **封装：** 封装是把数据（属性）和操作（方法）封装在一起，隐藏内部实现细节，只提供对外的接口

  - 私有成员：私有成员是以双下划线开头的属性和方法，外部无法直接访问，只能通过类内部的方法访问,现实事物有部分属性和行为是不对使用者开放的，同样在类中描述属性和方法的时候也需要达到这个要求，就需要定义私有成员了

    ```python
    class phone:
        __currrent_voltage = None

        def__keep_single_core(self):
            print("保持单核运行")
    ```

    - 私有成员无法被类对象使用，但是可以被类内部方法使用  

    ```python
        def call_by_5g(self):
            if self.__currrent_voltage >= 5:  
                print("5G通话")
            else:  
                self.__keep_single_core()
                print("电量不充足，使用单核运行")
    ```

### **继承：** 继承是类与类之间的关系，子类继承了父类的属性和方法，并添加了新的属性和方法

  - 为什么要继承？
    - 代码复用：子类可以直接使用父类的属性和方法，减少代码重复。
    - 扩展功能：子类可以在父类的基础上添加新的功能或修改现有功能。
  - 继承的语法：(单继承)

    ```python
    class 类名(父类名):
        类内容体
    ```

  - 多继承的语法：

    ```python
    class 类名(父类1, 父类2, ...):
        类内容体
    ```

    - `pass` 关键字：当类没有任何内容或者继承父类后不想补充新内容，可以使用 `pass` 关键字表示空类。

        ```python
        class 类名(父类1, 父类2, ...):
            pass
        ```

    - 多继承时，当不同父类有同名属性时，会按照从左到右的顺序查找属性，找到第一个匹配的属性。

        ```python
        class A:
            def method(self):
                print("A method")

        class B:
            def method(self):
                print("B method")

        class C(A, B):
            pass

        c = C()
        c.method()  # 输出：A method
        ```

### **复写：** 复写是子类重新定义父类的方法，子类可以修改或扩展父类的方法

  - 复写方法：直接在子类中定义与父类同名的属性或者方法，子类的方法会覆盖父类的方法。
  - 调用父类同名成员方法：
    - 1.调用父类成员：`父类名.成员变量/成员方法(self)`
    - 2.调用父类同名方法：`super().成员变量/成员方法名()`

### **类型注解:** 方便静态类型检查工具，IDE等第三方工具，在设计代码交互的地方提供数据类型的注解

  - 类型注解基础语法：`变量名: 数据类型 = 值`
  - 示例：

    ```python
    age: int = 18
    name: str = "张三"
    is_student: bool = True
    ```

    - 如上代码就可以告诉静态类型检查工具，变量`age`是整数类型，变量`name`是字符串类型，变量`is_student`是布尔类型。
  - 容器类型注解：
    - 基础语法：`变量名: 容器类型 = 值`
    - 详解类型：`变量名: 容器类型[元素类型] = 值`
      - 字典：`变量名: dict[键类型, 值类型] = 值`
  - 在注释中进行类型注解
    - 语法: `变量名 = 值  # type: 数据类型`  
    - 数据类型对于数据容器注解同样适用
  - 类型注解一般用于无法直接判断数据类型时，比如：

    ```python
    var_1 = random.randint(1, 100)  # type: int
    var_2 = json.loads(data)  # type: dict 
    ```

  - 类型注解是提示性的不是强制性的，它是个备注，即使标错了也不会报错
  - 函数(方法)的类型注解和基础类型注解一致，比如：

    ```python
    def func(a: int, b: int) -> int:
        return a + b
    ```

    - 期中`-> int`是对返回值的类型进行注解，表示该函数返回一个整数。
    - 同样的，函数中的类型注解也是提示性的而不是强制性的，即使类型错误也不会报错。
  - `Union`类型注解：表示一个变量可以是多个类型中的一个，比如：

    ```python
    from typing import Union
    my_list: list[Union[int, str]] = [1, "hello"]
    ```

    - `list[Union[int, str]]`表示my_list是一个列表，列表中的元素可以是整数或字符串。
  - `Union`基础语法：

    ```python
    Union[Type1, Type2, ...]
    ```

### **多态:** 多态指的是多种状态，即完成某个行为的时候，使用不同的对象会得到不同的状态

  - 实例展示：

    ```python
    class Animal:
        def make_sound(self):
            pass
    class Dog(Animal):
        def make_sound(self):
            print("汪汪汪")
    class Cat(Animal):
        def make_sound(self):
            print("喵喵喵")
    
    def make_sound(animal: Animal):
        animal.make_sound()
    
    dog = Dog()
    cat = Cat()
    make_sound(dog)    # 输出：汪汪汪
    make_sound(cat)    # 输出：喵喵喵
    ```

  - ~~很奇怪吧，脉门怎么自己开了~~
  - 使用同样的行为(函数)，传入不同的对象，却得到不同的结果，这就是多态
  - 多态经常作用在继承关系上，比如：
    - 函数(方法)形参声明接收父类对象，实机传入父类的子类对象进行工作
    - 即：以父类做定义声明，以子类做具体实现，用以获得统一行为，不同状态

### **抽象类(接口):** 由父类来定义一个空方法，具体实现方法由子类自行决定

  - 抽象类:含有抽象方法的类称之为抽象类
  - 抽象方法:方法体是空实现(`pass`)的方法称之为抽象方法
  - 为什么要使用抽象类？
    - 抽象类可以定义一组接口，子类必须实现这些接口，从而保证子类具有统一的行为。
    - 抽象类可以提供一些默认实现，子类可以选择覆盖或使用这些实现。
    - 抽象类好比定义一个标准，子类必须遵循这个标准来实现自己的功能。
  - 配合多态，可以实现:
    - 抽象的父类设计(设计标准)
    - 具体的子类实现(实现标准)

## Python高阶技巧

#### 闭包

- 在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，可以把这个使用外部函数变量的内部函数称之为闭包
- 简单闭包演示：

    ```python
    def outer_func(a):
        def inner_func(b):
            return a + b
        return inner_func
    closure = outer_func(10)
    print(closure(5))  # 输出：15
    ```

- `nonlocal` 关键字
  - `nonlocal` 关键字用于声明一个变量为非局部变量。当在嵌套函数中修改非局部变量时，必须使用 `nonlocal` 关键字来声明该变量。
  - 作用，可用于想在函数外部修改函数内部的变量值
  - ATM程序示例：

    ```python
    def fun_ATM_outer():
    """
    atm防外部篡改的闭包结构简单练习
    :return:
    """
    money = 100000
    def atm_menu():

        while True:
            print("-----------主菜单-----------")
            print("用户你好，欢迎来到ATM机，请输入操作")
            print("1.查询余额")
            print("2.取款")
            print("3.存款")
            print("4.退出")
            print("请输入你的选择：")
            choise = int(input())
            if choise == 1:
                atm_enquiry()
            elif choise == 2:
                atm_out()
            elif choise == 3:
                atm_in()
            elif choise == 4:
                print("感谢使用ATM机，再见")
                break
            else:
                print("请输入正确的选择!")

    def atm_enquiry():
        print(f"您的余额是{money}")

    def atm_in():
        nonlocal money
        money += int(input("请输入存款金额："))
        print(f"存款成功！您的余额为{money}")

    def atm_out():
        nonlocal money
        out_money = int(input("请输入取款金额："))
        if out_money > money:
            print("取款失败！您的余额不足")
        else:
            money -= out_money
            print(f"取款成功！您的余额为{money}")

    return atm_menu
    ```

- 闭包的优缺点：
  - 优点：
    - 无需定义全局变量即可实现通过函数，持续访问，修改某个变量的值
    - 闭包使用的变量位于外部函数内，难以被错误的调用修改
  - 缺点：
    - 由于内部函数持续引用外部函数的值，所以可能会导致这一部分空间不被释放，一直占用内存

#### 装饰器

- 装饰器也是一种闭包，主要功能就是在不破坏目标函数原有代码和功能的前提下，给目标函数添加新的功能
- 装饰器一般写法(闭包写法):

    ```python
    def outer(func):
        def inner():
            print("这是装饰器")
            func()
            print("这是装饰器")
        return inner
    def sleep():
        print("睡觉")
    func = outer(sleep)
    func()  # 输出：这是装饰器 \n 睡觉 \n 这是装饰器
    ```

- 装饰器语法(糖写法)：

    ```python
    def outer(func):
        def inner():
            print("这是装饰器")
            func()
            print("这是装饰器")
        return inner

    @outer
    def sleep():
        print("睡觉")

    sleep()  # 输出：这是装饰器 \n 睡觉 \n 这是装饰器
    ```

  - 装饰器的语法糖写法是通过在函数定义前加上 `@装饰器函数名` 来实现的，这样就不需要手动调用装饰器函数。
  - 糖写法的本质仍然是将原函数作为参数传递给装饰器函数，并返回一个新的函数，但是调用方式更为简洁，**不用手动赋值，直接写原函数名**即可。

#### 设计模式

- 设计模式是解决特定问题的通用解决方案，提供了一种可重用的代码结构和方法。
- 常见的设计模式包括：**单例模式，工厂模式**，观察者模式，策略模式等。
- **单例模式**：保证一个类只有一个实例，并提供一个全局访问点，这就是单例模式。
  - 适用场景：当需要确保一个类只有一个实例时，比如配置管理器，日志记录器等。
  - 基本写法：
    - 创建一个类，并在一个单独的文件中定义一个类，并使用一个静态变量来保存该类的唯一实例
    - 当需要使用的时候，在头部引用该实例，并进行想要的相应操作
  - 优点：
    - 确保全局只有一个实例，节省资源
    - 提供全局访问点，方便管理和使用
- **工厂模式**：提供一个创建对象的接口，但不暴露对象创建的具体实现。
  - 适用场景：当需要创建的对象类型较多，或者需要根据不同条件创建不同类型的对象时。
  - 基本写法：
    - 创建一个工厂类，并在该类中定义一个方法，根据传入的参数返回不同类型的对象
    - 使用工厂类来创建对象，而不是直接使用构造函数
  - 优点：
    - 大批量创建对象时，有统一的入口，易于代码维护
    - 当发生修改，仅修改工厂类的创建方法即可
    - 符合现实世界模式，即由工厂来制作产品(对象)
  - 示例:

    ```python
    class Person:
        pass
    class Student(Person):
        pass
    class Teacher(Person):
        pass
    class Worker(Person):
        pass
    class Factory:
        def get_person(self, type):
            if type == 's':
                return Student()
            elif type == 't':
                return Teacher()
            else:
                return Worker()
    factory = Factory()
    stu = factory.get_person('s')  # 创建一个学生对象
    tea = factory.get_person('t')  # 创建一个教师对象
    wor = factory.get_person('w')  # 创建一个工人对象
    ```

#### 多线程编程

- **进程：**就是一个程序，运行在系统之上，称这个程序为一个运行进程，分配进程id方便系统管理
- **线程：**线程是归属于进程的，一个进程可以开启多个线程，执行不同的任务，是进程实际工作的最小单位
- 进程之间的内存是隔离的，线程之间共享内存，就像进程是一家公司，线程是公司里的员工
- **并行执行：**指同一时间做不同的工作，进程之间就是并行的，线程也可以并行执行，称为多线程并行执行
- `threading`模块：Python提供了`threading`模块来支持多线程编程
  - 基本语法:`线程名 = threading.Thread(target=方法名, args=(参数1, 参数2, ...))`
    - `target`: 线程要执行的函数(方法)
    - `args`: 线程执行函数的参数
  - 启动线程:`线程名.start()`

#### Socket网络编程

- 双端：
  - 服务端：负责监听客户端的请求，处理客户端的连接和数据交互
  - 客户端：负责向服务端发送请求，接收服务端的响应
- 服务端编程基本步骤：
  - 1.创建Socket对象

    ```python
    import socket
    socket_server = socket.socket()
    ```

  - 2.绑定IP地址和端口号

    ```python
    socket_server.bind(host, port)
    ```

  - 3.监听客户端的连接请求

    ```python
    socket_server.listen(backlog)   
    # backlog为int整数，表述允许连接的数量，超出会等待，可以不填，不填会自动设置一个合理值
    ```

  - 4.接收客户端的连接，获得连接对象

    ```python
    conn, addr = socket_server.accept()
    print(f"接收到客户端，连接来自{addr}")
    # accept方法是阻塞方法，如果没有连接会卡在当前这一行不向下执行
    # accept方法返回的是一个二元元组，可以使用上述形式，用两个变量接收二元元组的内容
    ```

  - 5.接收客户端发送的数据

    ```python
    data = conn.recv(bufsize).decode("utf-8")
    # bufsize为int整数，表示接收数据的最大字节数,一般设置为1024
    # 返回的是字节类型数据，可以使用decode方法转换为字符串
    print(data)
    ```

  - 6.发送消息给客户端

    ```python
    msg = input("请输入要发送给客户端的消息：").encode("utf-8")
    conn.send(msg)
    ```

  - 7.关闭连接

    ```python
    conn.close()
    socket_server.close()
    ```

  - 5和6步可以重写成无限循环，这样服务端就可以一直收发客户端的消息：

    ```python
    print(f"接收到客户端，连接来自{addr}")
    while True:
        data = conn.recv(bufsize).decode("utf-8")
        if not data:  # 如果没有数据，说明客户端关闭了连接
            print("客户端已断开连接")
            break
        print(data)
        msg = input("请输入要发送给客户端的消息：").encode("utf-8")
        if msg.lower() == 'exit':
            print("退出服务端")
            break
        conn.send(msg)
    conn.close()
    ```

- 客户端编程基本步骤：
  - 1.创建Socket对象

    ```python
    import socket
    socket_client = socket.socket()
    ```

  - 2.连接服务端

    ```python
    socket_client.connect((host, port))
    ```

  - 3.发送消息给服务端

    ```python
    msg = input("请输入要发送给服务端的消息：").encode("utf-8")
    socket_client.send(msg)
    ```

  - 4.接收服务端的响应

    ```python
    data = socket_client.recv(bufsize).decode("utf-8")
    print(data)
    ```

  - 5.关闭连接

    ```python
    socket_client.close()
    ```

  - 4和5步可以重写成无限循环，这样客户端就可以一直收发服务端的消息：

    ```python
    while True:
        msg = input("请输入要发送给服务端的消息：").encode("utf-8")
        if msg.lower() == 'exit':
            print("退出客户端")
            socket_client.close()
            break
        socket_client.send(msg)
        data = socket_client.recv(bufsize).decode("utf-8")
        print(data)
    ```

#### 正则表达式

- 正则表达式又称为规则表达式，是使用单个字符串来描述匹配某个句法规则的字符串，常备用于检索替换符合某个句法规则的文本
- 正则的三个基础方法：
  - `re.match`:从被匹配字符串开头进行匹配，匹配成功就返回匹配对象(包含匹配的信息)，失败就返回`None`(如果开头就不匹配就返回`None`)

    ```python
    import re
    s = "python itheima python itheima python itheima"
    result = re.match(r"python", s)
    print(result)  # 输出：<re.Match object; span=(0, 6), match='python'>
    print(result.span())  # 输出： (0, 6)
    print(result.group())  # 输出： python
    ```

  - `re.search`:搜索整个字符串，找出第一个匹配的字符串就停止，返回匹配的字符串，如果没有匹配的字符串，则返回`None`

    ```python
    s = "1python itheima python itheima python itheima"
    result = re.search(r"python", s)
    print(result)  # 输出：<re.Match object; span=(1, 7), match='python'>
    ```

  - `re.findall`:匹配整个字符串，返回所有匹配的字符串，如果没有匹配的字符串，则返回空列表

    ```python
    s = "1python itheima python itheima python itheima"
    result = re.findall(r"python", s)
    print(result)  # 输出：['python', 'python', 'python']
    ```

- 元字符匹配：
  - 单字符匹配
    - `.`:匹配任意字符，除了换行符，`\.`匹配本身
    - `[^]`:匹配任意字符，除了括号列举的字符
    - `[]`:匹配括号列举的字符
    - `\d`:匹配数字，等价于`[0-9]`
    - `\D`:匹配非数字，等价于`[^0-9]`
    - `\s`:匹配空白字符，等价于`[ \t\n\r\f\v]`
    - `\S`:匹配非空白字符，等价于`[^ \t\n\r\f\v]`
    - `\w`:匹配单词字符，等价于`[a-zA-Z0-9_]`
    - `\W`:匹配非单词字符，等价于`[^a-zA-Z0-9_]`
  - 数量匹配：
    - `*`:匹配0个或多个前面的字符
    - `+`:匹配1个或多个前面的字符
    - `?`:匹配0个或1个前面的字符
    - `{n}`:匹配n个前面的字符
    - `{n,}`:匹配n个或多个前面的字符
    - `{n,m}`:匹配n到m个前面的字符
  - 边界匹配：
    - `^`:匹配字符串的开头
    - `$`:匹配字符串的结尾
    - `\b`:匹配单词边界
    - `\B`:匹配非单词边界
  - 分组匹配：
    - `()`:匹配括号内的内容
    - `|`:匹配左右任意一个表达式

#### 递归

- 概念：即函数(方法)直接调用自身的特殊编程写法

```python
def fun():
    if ...:
        fun()
    return ...
```

- 使用场景：
  - 解决一些复杂问题时，可以使用递归来简化代码
  - 例如：寻找文件，树形结构的遍历、汉诺塔问题、斐波那契数列等
- 注意事项：
  - 递归调用的终止条件必须明确，否则容易变成无限递归
  - 确保返回值的传递，确保从最内层，一层层返回到最外层

---
基础Python到此结束  
**完结撒花**
